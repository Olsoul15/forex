"""
Domain-specific type definitions for the Forex AI Trading System.
"""

from enum import Enum, auto
from datetime import datetime
from typing import Dict, List, Any, Optional, Union, Callable
from pydantic import BaseModel, Field, validator


class TimeFrame(str, Enum):
    """Timeframes for market data analysis."""

    M1 = "1m"  # 1 minute
    M5 = "5m"  # 5 minutes
    M15 = "15m"  # 15 minutes
    M30 = "30m"  # 30 minutes
    H1 = "1h"  # 1 hour
    H4 = "4h"  # 4 hours
    D1 = "1d"  # 1 day
    W1 = "1w"  # 1 week
    MN = "1M"  # 1 month


class CurrencyPair(BaseModel):
    """
    Currency pair representation (e.g., EUR/USD).

    Attributes:
        base: Base currency (e.g., EUR)
        quote: Quote currency (e.g., USD)
    """

    base: str
    quote: str

    @validator("base", "quote")
    def validate_currency_code(cls, v):
        """Validate currency code is a 3-letter code."""
        if not isinstance(v, str) or len(v) != 3:
            raise ValueError(f"Currency code must be a 3-letter string, got: {v}")
        return v.upper()

    def __str__(self) -> str:
        """String representation in standard format."""
        return f"{self.base}/{self.quote}"


class MarketDataPoint(BaseModel):
    """
    Single market data point.

    Attributes:
        timestamp: Time of the data point
        open: Opening price
        high: Highest price during the period
        low: Lowest price during the period
        close: Closing price
        volume: Optional trading volume
    """

    timestamp: datetime
    open: float = Field(..., gt=0)
    high: float = Field(..., gt=0)
    low: float = Field(..., gt=0)
    close: float = Field(..., gt=0)
    volume: Optional[float] = Field(None, ge=0)

    @validator("high")
    def high_greater_than_low(cls, v, values):
        """Validate high price is greater than or equal to low price."""
        if "low" in values and v < values["low"]:
            raise ValueError(
                f"High price ({v}) cannot be less than low price ({values['low']})"
            )
        return v

    @validator("open", "close")
    def prices_in_range(cls, v, values):
        """Validate open and close prices are within high-low range."""
        if "high" in values and "low" in values:
            if v > values["high"]:
                raise ValueError(
                    f"Price ({v}) cannot be greater than high price ({values['high']})"
                )
            if v < values["low"]:
                raise ValueError(
                    f"Price ({v}) cannot be less than low price ({values['low']})"
                )
        return v


class MarketData(BaseModel):
    """
    Collection of market data points for a currency pair and timeframe.

    Attributes:
        currency_pair: The currency pair
        timeframe: Data timeframe
        data: List of market data points
        start_time: Start time of the data range
        end_time: End time of the data range
    """

    currency_pair: CurrencyPair
    timeframe: TimeFrame
    data: List[MarketDataPoint]
    start_time: datetime
    end_time: datetime

    @validator("data")
    def validate_data_not_empty(cls, v):
        """Validate data is not empty."""
        if not v:
            raise ValueError("Market data cannot be empty")
        return v

    @validator("end_time")
    def validate_time_range(cls, v, values):
        """Validate end_time is after start_time."""
        if "start_time" in values and v <= values["start_time"]:
            raise ValueError("End time must be after start time")
        return v


class MarketCondition(BaseModel):
    """
    Market condition analysis.

    Attributes:
        trend: Overall market trend
        volatility: Market volatility level
        volume: Trading volume level
        support_resistance: Key support and resistance levels
    """

    trend: str = Field(..., pattern=r"^(strong_up|up|neutral|down|strong_down)$")
    volatility: float = Field(..., ge=0, le=1)
    volume: str = Field(..., pattern=r"^(very_low|low|average|high|very_high)$")
    support_resistance: Dict[str, float]


class TradingSignal(BaseModel):
    """
    Trading signal generated by a strategy.

    Attributes:
        currency_pair: Currency pair
        direction: Direction of the trade (buy/sell)
        entry_price: Suggested entry price
        stop_loss: Suggested stop loss price
        take_profit: Suggested take profit price
        timeframe: Signal timeframe
        strategy_id: ID of the strategy that generated the signal
        confidence: Signal confidence level (0-1)
        expiration: Signal expiration time
    """

    currency_pair: CurrencyPair
    direction: str = Field(..., pattern=r"^(buy|sell)$")
    entry_price: float = Field(..., gt=0)
    stop_loss: float = Field(..., gt=0)
    take_profit: float = Field(..., gt=0)
    timeframe: TimeFrame
    strategy_id: str
    confidence: float = Field(..., ge=0, le=1)
    expiration: datetime

    @validator("stop_loss", "take_profit")
    def validate_prices(cls, v, values, **kwargs):
        """Validate stop loss and take profit based on direction."""
        if "direction" in values and "entry_price" in values:
            entry = values["entry_price"]
            field_name = kwargs.get("field", None)

            if values["direction"] == "buy":
                if field_name == "stop_loss" and v >= entry:
                    raise ValueError(
                        f"Stop loss ({v}) must be below entry price ({entry}) for buy signals"
                    )
                if field_name == "take_profit" and v <= entry:
                    raise ValueError(
                        f"Take profit ({v}) must be above entry price ({entry}) for buy signals"
                    )
            else:  # sell
                if field_name == "stop_loss" and v <= entry:
                    raise ValueError(
                        f"Stop loss ({v}) must be above entry price ({entry}) for sell signals"
                    )
                if field_name == "take_profit" and v >= entry:
                    raise ValueError(
                        f"Take profit ({v}) must be below entry price ({entry}) for sell signals"
                    )
        return v


class Strategy(BaseModel):
    """
    Trading strategy definition.

    Attributes:
        id: Unique identifier for the strategy
        name: Strategy name
        description: Strategy description
        timeframes: Supported timeframes
        currency_pairs: Supported currency pairs
        parameters: Strategy parameters
        version: Strategy version
        created_at: Creation timestamp
        updated_at: Last update timestamp
        performance: Performance metrics
    """

    id: str
    name: str
    description: str
    timeframes: List[TimeFrame]
    currency_pairs: List[CurrencyPair]
    parameters: Dict[str, Any]
    version: str
    created_at: datetime
    updated_at: datetime
    performance: Dict[str, float] = Field(default_factory=dict)


class CandlestickStrategy(Strategy):
    """
    Candlestick pattern-based trading strategy.

    Attributes:
        patterns: List of candlestick patterns used by the strategy
        confirmation_indicators: Optional list of indicators used for confirmation
    """

    patterns: List[str]
    confirmation_indicators: Optional[List[str]] = None


class IndicatorStrategy(Strategy):
    """
    Technical indicator-based trading strategy.

    Attributes:
        indicators: List of technical indicators used by the strategy
        indicator_settings: Settings for each indicator
        entry_conditions: Conditions for entering a trade
        exit_conditions: Conditions for exiting a trade
    """

    indicators: List[str]
    indicator_settings: Dict[str, Dict[str, Any]]
    entry_conditions: List[str]
    exit_conditions: List[str]


class PineScriptStrategy(Strategy):
    """
    Strategy defined in PineScript.

    Attributes:
        pine_script: The PineScript code for the strategy
        python_equivalent: Optional Python equivalent of the PineScript
    """

    pine_script: str
    python_equivalent: Optional[str] = None


class Order(BaseModel):
    """
    Trading order.

    Attributes:
        id: Order ID from the broker
        currency_pair: Currency pair
        direction: Direction of the trade (buy/sell)
        entry_price: Entry price
        stop_loss: Stop loss price
        take_profit: Take profit price
        volume: Order volume in lots
        status: Order status
        open_time: Time when the order was opened
        close_time: Time when the order was closed (if closed)
        profit_loss: Profit or loss from the order (if closed)
        strategy_id: ID of the strategy that generated the order
    """

    id: Optional[str] = None
    currency_pair: CurrencyPair
    direction: str = Field(..., pattern=r"^(buy|sell)$")
    entry_price: float = Field(..., gt=0)
    stop_loss: float = Field(..., gt=0)
    take_profit: float = Field(..., gt=0)
    volume: float = Field(..., gt=0)
    status: str = Field(..., pattern=r"^(pending|open|closed|canceled|rejected|error)$")
    open_time: datetime
    close_time: Optional[datetime] = None
    profit_loss: Optional[float] = None
    strategy_id: str
    comment: Optional[str] = None
    magic_number: Optional[int] = None


class AgentMetrics(BaseModel):
    """
    Metrics for an agent or model.

    Attributes:
        calls: Number of times the agent/model was called
        errors: Number of errors encountered
        avg_response_time: Average response time in seconds
        last_call_time: Last time the agent/model was called
        success_rate: Success rate (0-1)
    """

    calls: int = 0
    errors: int = 0
    avg_response_time: float = 0.0
    last_call_time: Optional[datetime] = None
    success_rate: float = 1.0

    @validator("success_rate")
    def validate_success_rate(cls, v):
        """Validate success rate is between 0 and 1."""
        if v < 0 or v > 1:
            raise ValueError(f"Success rate must be between 0 and 1, got: {v}")
        return v


class AgentMemoryEntry(BaseModel):
    """
    Entry in the agent's memory.

    Attributes:
        id: Unique identifier for the memory entry
        timestamp: When the entry was created
        input_data: The input that was processed
        output_data: The output that was generated
        metadata: Additional metadata about the processing
    """

    id: str
    timestamp: datetime
    input_data: Any
    output_data: Optional[Any] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)


class AgentTool(BaseModel):
    """
    Tool definition for an agent.

    Attributes:
        name: Tool name
        description: Tool description
        enabled: Whether the tool is enabled
        required_permissions: Permissions required to use this tool
    """

    name: str
    description: str
    enabled: bool = True
    required_permissions: List[str] = Field(default_factory=list)


class PerformanceMetrics(BaseModel):
    """
    Performance metrics for a trading strategy.

    Attributes:
        win_rate: Win rate (0-1)
        profit_factor: Profit factor
        max_drawdown: Maximum drawdown
        avg_win: Average win
        avg_loss: Average loss
        total_trades: Total trades
        expectancy: Expected return per trade
        sharpe_ratio: Sharpe ratio
    """

    win_rate: float = Field(..., ge=0, le=1)
    profit_factor: float = Field(..., ge=0)
    max_drawdown: float = Field(..., ge=0, le=1)
    avg_win: float
    avg_loss: float
    total_trades: int = Field(..., ge=0)
    expectancy: float
    sharpe_ratio: float

    @validator("avg_loss")
    def validate_avg_loss(cls, v):
        """Validate average loss is negative or zero."""
        if v > 0:
            raise ValueError(f"Average loss should be negative or zero, got: {v}")
        return v


class BacktestStatus(Enum):
    """Represents the status of a backtest job."""

    PENDING = auto()
    RUNNING = auto()
    COMPLETED = auto()
    FAILED = auto()
    CANCELLED = auto()


class TaskStatus(Enum):
    """Represents the status of a general asynchronous task."""

    PENDING = auto()
    RUNNING = auto()
    SUCCESS = auto()
    FAILURE = auto()
    RETRY = auto()
